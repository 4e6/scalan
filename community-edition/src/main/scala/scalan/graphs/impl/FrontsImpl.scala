package scalan.graphs
package impl

import scala.annotation.unchecked.uncheckedVariance
import scalan.common.Default
import scalan._
import scalan.collection.{CollectionsDslExp, CollectionsDslSeq, CollectionsDsl}
import scala.reflect.runtime.universe._
import scala.reflect._
import scalan.common.Default

// Abs -----------------------------------
trait FrontsAbs extends ScalanCommunityDsl with Fronts {
  self: FrontsDsl =>
  // single proxy for each type family
  implicit def proxyFront(p: Rep[Front]): Front = {
    implicit val tag = weakTypeTag[Front]
    proxyOps[Front](p)(TagImplicits.typeTagToClassTag[Front])
  }

  abstract class FrontElem[From, To <: Front](iso: Iso[From, To])
    extends ViewElem[From, To](iso) {
    override def convert(x: Rep[Reifiable[_]]) = convertFront(x.asRep[Front])
    def convertFront(x : Rep[Front]): Rep[To]
  }
  trait FrontCompanionElem extends CompanionElem[FrontCompanionAbs]
  implicit lazy val FrontCompanionElem: FrontCompanionElem = new FrontCompanionElem {
    lazy val tag = weakTypeTag[FrontCompanionAbs]
    protected def getDefaultRep = Front
  }

  abstract class FrontCompanionAbs extends CompanionBase[FrontCompanionAbs] with FrontCompanion {
    override def toString = "Front"
  }
  def Front: Rep[FrontCompanionAbs]
  implicit def proxyFrontCompanion(p: Rep[FrontCompanion]): FrontCompanion = {
    proxyOps[FrontCompanion](p)
  }

  // elem for concrete class
  class BaseFrontElem(iso: Iso[BaseFrontData, BaseFront])
    extends FrontElem[BaseFrontData, BaseFront](iso) {
    def convertFront(x: Rep[Front]) = // Converter is not generated by meta
!!!("Cannot convert from Front to BaseFront: missing fields List(bits)")
  }

  // state representation type
  type BaseFrontData = (Collection[Int], PBitSet)

  // 3) Iso for concrete class
  class BaseFrontIso
    extends Iso[BaseFrontData, BaseFront] {
    override def from(p: Rep[BaseFront]) =
      unmkBaseFront(p) match {
        case Some((set, bits)) => Pair(set, bits)
        case None => !!!
      }
    override def to(p: Rep[(Collection[Int], PBitSet)]) = {
      val Pair(set, bits) = p
      BaseFront(set, bits)
    }
    lazy val tag = {
      weakTypeTag[BaseFront]
    }
    lazy val defaultRepTo = Default.defaultVal[Rep[BaseFront]](BaseFront(element[Collection[Int]].defaultRepValue, element[PBitSet].defaultRepValue))
    lazy val eTo = new BaseFrontElem(this)
  }
  // 4) constructor and deconstructor
  abstract class BaseFrontCompanionAbs extends CompanionBase[BaseFrontCompanionAbs] with BaseFrontCompanion {
    override def toString = "BaseFront"
    def apply(p: Rep[BaseFrontData]): Rep[BaseFront] =
      isoBaseFront.to(p)
    def apply(set: Rep[Collection[Int]], bits: Rep[PBitSet]): Rep[BaseFront] =
      mkBaseFront(set, bits)
    def unapply(p: Rep[BaseFront]) = unmkBaseFront(p)
  }
  def BaseFront: Rep[BaseFrontCompanionAbs]
  implicit def proxyBaseFrontCompanion(p: Rep[BaseFrontCompanionAbs]): BaseFrontCompanionAbs = {
    proxyOps[BaseFrontCompanionAbs](p)
  }

  class BaseFrontCompanionElem extends CompanionElem[BaseFrontCompanionAbs] {
    lazy val tag = weakTypeTag[BaseFrontCompanionAbs]
    protected def getDefaultRep = BaseFront
  }
  implicit lazy val BaseFrontCompanionElem: BaseFrontCompanionElem = new BaseFrontCompanionElem

  implicit def proxyBaseFront(p: Rep[BaseFront]): BaseFront =
    proxyOps[BaseFront](p)

  implicit class ExtendedBaseFront(p: Rep[BaseFront]) {
    def toData: Rep[BaseFrontData] = isoBaseFront.from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoBaseFront: Iso[BaseFrontData, BaseFront] =
    new BaseFrontIso

  // 6) smart constructor and deconstructor
  def mkBaseFront(set: Rep[Collection[Int]], bits: Rep[PBitSet]): Rep[BaseFront]
  def unmkBaseFront(p: Rep[BaseFront]): Option[(Rep[Collection[Int]], Rep[PBitSet])]

  // elem for concrete class
  class MapBasedFrontElem(iso: Iso[MapBasedFrontData, MapBasedFront])
    extends FrontElem[MapBasedFrontData, MapBasedFront](iso) {
    def convertFront(x: Rep[Front]) = // Converter is not generated by meta
!!!("Cannot convert from Front to MapBasedFront: missing fields List(mmap)")
  }

  // state representation type
  type MapBasedFrontData = MMap[Int,Unit]

  // 3) Iso for concrete class
  class MapBasedFrontIso
    extends Iso[MapBasedFrontData, MapBasedFront] {
    override def from(p: Rep[MapBasedFront]) =
      unmkMapBasedFront(p) match {
        case Some((mmap)) => mmap
        case None => !!!
      }
    override def to(p: Rep[MMap[Int,Unit]]) = {
      val mmap = p
      MapBasedFront(mmap)
    }
    lazy val tag = {
      weakTypeTag[MapBasedFront]
    }
    lazy val defaultRepTo = Default.defaultVal[Rep[MapBasedFront]](MapBasedFront(element[MMap[Int,Unit]].defaultRepValue))
    lazy val eTo = new MapBasedFrontElem(this)
  }
  // 4) constructor and deconstructor
  abstract class MapBasedFrontCompanionAbs extends CompanionBase[MapBasedFrontCompanionAbs] with MapBasedFrontCompanion {
    override def toString = "MapBasedFront"

    def apply(mmap: Rep[MMap[Int,Unit]]): Rep[MapBasedFront] =
      mkMapBasedFront(mmap)
    def unapply(p: Rep[MapBasedFront]) = unmkMapBasedFront(p)
  }
  def MapBasedFront: Rep[MapBasedFrontCompanionAbs]
  implicit def proxyMapBasedFrontCompanion(p: Rep[MapBasedFrontCompanionAbs]): MapBasedFrontCompanionAbs = {
    proxyOps[MapBasedFrontCompanionAbs](p)
  }

  class MapBasedFrontCompanionElem extends CompanionElem[MapBasedFrontCompanionAbs] {
    lazy val tag = weakTypeTag[MapBasedFrontCompanionAbs]
    protected def getDefaultRep = MapBasedFront
  }
  implicit lazy val MapBasedFrontCompanionElem: MapBasedFrontCompanionElem = new MapBasedFrontCompanionElem

  implicit def proxyMapBasedFront(p: Rep[MapBasedFront]): MapBasedFront =
    proxyOps[MapBasedFront](p)

  implicit class ExtendedMapBasedFront(p: Rep[MapBasedFront]) {
    def toData: Rep[MapBasedFrontData] = isoMapBasedFront.from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoMapBasedFront: Iso[MapBasedFrontData, MapBasedFront] =
    new MapBasedFrontIso

  // 6) smart constructor and deconstructor
  def mkMapBasedFront(mmap: Rep[MMap[Int,Unit]]): Rep[MapBasedFront]
  def unmkMapBasedFront(p: Rep[MapBasedFront]): Option[(Rep[MMap[Int,Unit]])]
}

// Seq -----------------------------------
trait FrontsSeq extends FrontsDsl with ScalanCommunityDslSeq {
  self: FrontsDslSeq =>
  lazy val Front: Rep[FrontCompanionAbs] = new FrontCompanionAbs with UserTypeSeq[FrontCompanionAbs, FrontCompanionAbs] {
    lazy val selfType = element[FrontCompanionAbs]
  }

  case class SeqBaseFront
      (override val set: Rep[Collection[Int]], override val bits: Rep[PBitSet])

    extends BaseFront(set, bits)
        with UserTypeSeq[Front, BaseFront] {
    lazy val selfType = element[BaseFront].asInstanceOf[Elem[Front]]
  }
  lazy val BaseFront = new BaseFrontCompanionAbs with UserTypeSeq[BaseFrontCompanionAbs, BaseFrontCompanionAbs] {
    lazy val selfType = element[BaseFrontCompanionAbs]
  }

  def mkBaseFront
      (set: Rep[Collection[Int]], bits: Rep[PBitSet]) =
      new SeqBaseFront(set, bits)
  def unmkBaseFront(p: Rep[BaseFront]) =
    Some((p.set, p.bits))

  case class SeqMapBasedFront
      (override val mmap: Rep[MMap[Int,Unit]])

    extends MapBasedFront(mmap)
        with UserTypeSeq[Front, MapBasedFront] {
    lazy val selfType = element[MapBasedFront].asInstanceOf[Elem[Front]]
  }
  lazy val MapBasedFront = new MapBasedFrontCompanionAbs with UserTypeSeq[MapBasedFrontCompanionAbs, MapBasedFrontCompanionAbs] {
    lazy val selfType = element[MapBasedFrontCompanionAbs]
  }

  def mkMapBasedFront
      (mmap: Rep[MMap[Int,Unit]]) =
      new SeqMapBasedFront(mmap)
  def unmkMapBasedFront(p: Rep[MapBasedFront]) =
    Some((p.mmap))
}

// Exp -----------------------------------
trait FrontsExp extends FrontsDsl with ScalanCommunityDslExp {
  self: FrontsDslExp =>
  lazy val Front: Rep[FrontCompanionAbs] = new FrontCompanionAbs with UserTypeDef[FrontCompanionAbs, FrontCompanionAbs] {
    lazy val selfType = element[FrontCompanionAbs]
    override def mirror(t: Transformer) = this
  }

  case class ExpBaseFront
      (override val set: Rep[Collection[Int]], override val bits: Rep[PBitSet])

    extends BaseFront(set, bits) with UserTypeDef[Front, BaseFront] {
    lazy val selfType = element[BaseFront].asInstanceOf[Elem[Front]]
    override def mirror(t: Transformer) = ExpBaseFront(t(set), t(bits))
  }

  lazy val BaseFront: Rep[BaseFrontCompanionAbs] = new BaseFrontCompanionAbs with UserTypeDef[BaseFrontCompanionAbs, BaseFrontCompanionAbs] {
    lazy val selfType = element[BaseFrontCompanionAbs]
    override def mirror(t: Transformer) = this
  }

  object BaseFrontMethods {
    object contains {
      def unapply(d: Def[_]): Option[(Rep[BaseFront], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(v, _*), _) if receiver.elem.isInstanceOf[BaseFrontElem] && method.getName == "contains" =>
          Some((receiver, v)).asInstanceOf[Option[(Rep[BaseFront], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[BaseFront], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object append {
      def unapply(d: Def[_]): Option[(Rep[BaseFront], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(v, _*), _) if receiver.elem.isInstanceOf[BaseFrontElem] && method.getName == "append" =>
          Some((receiver, v)).asInstanceOf[Option[(Rep[BaseFront], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[BaseFront], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object BaseFrontCompanionMethods {
    object defaultOf {
      def unapply(d: Def[_]): Option[Unit] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[BaseFrontCompanionElem] && method.getName == "defaultOf" =>
          Some(()).asInstanceOf[Option[Unit]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Unit] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkBaseFront
    (set: Rep[Collection[Int]], bits: Rep[PBitSet]) =
    new ExpBaseFront(set, bits)
  def unmkBaseFront(p: Rep[BaseFront]) =
    Some((p.set, p.bits))

  case class ExpMapBasedFront
      (override val mmap: Rep[MMap[Int,Unit]])

    extends MapBasedFront(mmap) with UserTypeDef[Front, MapBasedFront] {
    lazy val selfType = element[MapBasedFront].asInstanceOf[Elem[Front]]
    override def mirror(t: Transformer) = ExpMapBasedFront(t(mmap))
  }

  lazy val MapBasedFront: Rep[MapBasedFrontCompanionAbs] = new MapBasedFrontCompanionAbs with UserTypeDef[MapBasedFrontCompanionAbs, MapBasedFrontCompanionAbs] {
    lazy val selfType = element[MapBasedFrontCompanionAbs]
    override def mirror(t: Transformer) = this
  }

  object MapBasedFrontMethods {
    object contains {
      def unapply(d: Def[_]): Option[(Rep[MapBasedFront], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(v, _*), _) if receiver.elem.isInstanceOf[MapBasedFrontElem] && method.getName == "contains" =>
          Some((receiver, v)).asInstanceOf[Option[(Rep[MapBasedFront], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[MapBasedFront], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object append {
      def unapply(d: Def[_]): Option[(Rep[MapBasedFront], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(v, _*), _) if receiver.elem.isInstanceOf[MapBasedFrontElem] && method.getName == "append" =>
          Some((receiver, v)).asInstanceOf[Option[(Rep[MapBasedFront], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[MapBasedFront], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object set {
      def unapply(d: Def[_]): Option[Rep[MapBasedFront]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[MapBasedFrontElem] && method.getName == "set" =>
          Some(receiver).asInstanceOf[Option[Rep[MapBasedFront]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[MapBasedFront]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object MapBasedFrontCompanionMethods {
    object defaultOf {
      def unapply(d: Def[_]): Option[Unit] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[MapBasedFrontCompanionElem] && method.getName == "defaultOf" =>
          Some(()).asInstanceOf[Option[Unit]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Unit] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkMapBasedFront
    (mmap: Rep[MMap[Int,Unit]]):Rep[MapBasedFront]  =
    new ExpMapBasedFront(mmap)
  def unmkMapBasedFront(p: Rep[MapBasedFront]) =
    Some((p.mmap))

  object FrontMethods {
    object contains {
      def unapply(d: Def[_]): Option[(Rep[Front], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(v, _*), _) if receiver.elem.isInstanceOf[FrontElem[_, _]] && method.getName == "contains" =>
          Some((receiver, v)).asInstanceOf[Option[(Rep[Front], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Front], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object append {
      def unapply(d: Def[_]): Option[(Rep[Front], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(v, _*), _) if receiver.elem.isInstanceOf[FrontElem[_, _]] && method.getName == "append" =>
          Some((receiver, v)).asInstanceOf[Option[(Rep[Front], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Front], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object set {
      def unapply(d: Def[_]): Option[Rep[Front]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[FrontElem[_, _]] && method.getName == "set" =>
          Some(receiver).asInstanceOf[Option[Rep[Front]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Front]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object FrontCompanionMethods {
    object defaultOf {
      def unapply(d: Def[_]): Option[Unit] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[FrontCompanionElem] && method.getName == "defaultOf" =>
          Some(()).asInstanceOf[Option[Unit]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Unit] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object fromStartNode {
      def unapply(d: Def[_]): Option[(Rep[Int], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(start, len, _*), _) if receiver.elem.isInstanceOf[FrontCompanionElem] && method.getName == "fromStartNode" =>
          Some((start, len)).asInstanceOf[Option[(Rep[Int], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Int], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object fromStartNodeMap {
      def unapply(d: Def[_]): Option[(Rep[Int], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(start, len, _*), _) if receiver.elem.isInstanceOf[FrontCompanionElem] && method.getName == "fromStartNodeMap" =>
          Some((start, len)).asInstanceOf[Option[(Rep[Int], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Int], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }
}
