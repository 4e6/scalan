package scalan.graphs
package impl

import scala.annotation.unchecked.uncheckedVariance
import scalan.common.Default
import scalan._
import scalan.collection.{CollectionsDslExp, CollectionsDslSeq, CollectionsDsl}
import scala.reflect.runtime.universe._
import scala.reflect._
import scalan.common.Default

// Abs -----------------------------------
trait FrontsAbs extends ScalanCommunityDsl with Fronts {
  self: FrontsDsl =>
  // single proxy for each type family
  implicit def proxyFront(p: Rep[Front]): Front = {
    implicit val tag = weakTypeTag[Front]
    proxyOps[Front](p)(TagImplicits.typeTagToClassTag[Front])
  }

  abstract class FrontElem[From, To <: Front](iso: Iso[From, To])
    extends ViewElem[From, To](iso) {
    override def convert(x: Rep[Reifiable[_]]) = convertFront(x.asRep[Front])
    def convertFront(x : Rep[Front]): Rep[To]
  }
  trait FrontCompanionElem extends CompanionElem[FrontCompanionAbs]
  implicit lazy val FrontCompanionElem: FrontCompanionElem = new FrontCompanionElem {
    lazy val tag = weakTypeTag[FrontCompanionAbs]
    protected def getDefaultRep = Front
  }

  abstract class FrontCompanionAbs extends CompanionBase[FrontCompanionAbs] with FrontCompanion {
    override def toString = "Front"
  }
  def Front: Rep[FrontCompanionAbs]
  implicit def proxyFrontCompanion(p: Rep[FrontCompanion]): FrontCompanion = {
    proxyOps[FrontCompanion](p)
  }

  // elem for concrete class
  class BaseFrontElem(iso: Iso[BaseFrontData, BaseFront])
    extends FrontElem[BaseFrontData, BaseFront](iso) {
    def convertFront(x: Rep[Front]) = // Converter is not generated by meta
!!!("Cannot convert from Front to BaseFront: missing fields List(bits)")
  }

  // state representation type
  type BaseFrontData = (Collection[Int], PBitSet)

  // 3) Iso for concrete class
  class BaseFrontIso
    extends Iso[BaseFrontData, BaseFront] {
    override def from(p: Rep[BaseFront]) =
      unmkBaseFront(p) match {
        case Some((set, bits)) => Pair(set, bits)
        case None => !!!
      }
    override def to(p: Rep[(Collection[Int], PBitSet)]) = {
      val Pair(set, bits) = p
      BaseFront(set, bits)
    }
    lazy val tag = {
      weakTypeTag[BaseFront]
    }
    lazy val defaultRepTo = Default.defaultVal[Rep[BaseFront]](BaseFront(element[Collection[Int]].defaultRepValue, element[PBitSet].defaultRepValue))
    lazy val eTo = new BaseFrontElem(this)
  }
  // 4) constructor and deconstructor
  abstract class BaseFrontCompanionAbs extends CompanionBase[BaseFrontCompanionAbs] with BaseFrontCompanion {
    override def toString = "BaseFront"
    def apply(p: Rep[BaseFrontData]): Rep[BaseFront] =
      isoBaseFront.to(p)
    def apply(set: Rep[Collection[Int]], bits: Rep[PBitSet]): Rep[BaseFront] =
      mkBaseFront(set, bits)
    def unapply(p: Rep[BaseFront]) = unmkBaseFront(p)
  }
  def BaseFront: Rep[BaseFrontCompanionAbs]
  implicit def proxyBaseFrontCompanion(p: Rep[BaseFrontCompanionAbs]): BaseFrontCompanionAbs = {
    proxyOps[BaseFrontCompanionAbs](p)
  }

  class BaseFrontCompanionElem extends CompanionElem[BaseFrontCompanionAbs] {
    lazy val tag = weakTypeTag[BaseFrontCompanionAbs]
    protected def getDefaultRep = BaseFront
  }
  implicit lazy val BaseFrontCompanionElem: BaseFrontCompanionElem = new BaseFrontCompanionElem

  implicit def proxyBaseFront(p: Rep[BaseFront]): BaseFront =
    proxyOps[BaseFront](p)

  implicit class ExtendedBaseFront(p: Rep[BaseFront]) {
    def toData: Rep[BaseFrontData] = isoBaseFront.from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoBaseFront: Iso[BaseFrontData, BaseFront] =
    new BaseFrontIso

  // 6) smart constructor and deconstructor
  def mkBaseFront(set: Rep[Collection[Int]], bits: Rep[PBitSet]): Rep[BaseFront]
  def unmkBaseFront(p: Rep[BaseFront]): Option[(Rep[Collection[Int]], Rep[PBitSet])]

  // elem for concrete class
  class HsFrontElem(iso: Iso[HsFrontData, HsFront])
    extends FrontElem[HsFrontData, HsFront](iso) {
    def convertFront(x: Rep[Front]) = // Converter is not generated by meta
!!!("Cannot convert from Front to HsFront: missing fields List(hashSet)")
  }

  // state representation type
  type HsFrontData = SHashSet[Int]

  // 3) Iso for concrete class
  class HsFrontIso
    extends Iso[HsFrontData, HsFront] {
    override def from(p: Rep[HsFront]) =
      unmkHsFront(p) match {
        case Some((hashSet)) => hashSet
        case None => !!!
      }
    override def to(p: Rep[SHashSet[Int]]) = {
      val hashSet = p
      HsFront(hashSet)
    }
    lazy val tag = {
      weakTypeTag[HsFront]
    }
    lazy val defaultRepTo = Default.defaultVal[Rep[HsFront]](HsFront(element[SHashSet[Int]].defaultRepValue))
    lazy val eTo = new HsFrontElem(this)
  }
  // 4) constructor and deconstructor
  abstract class HsFrontCompanionAbs extends CompanionBase[HsFrontCompanionAbs] with HsFrontCompanion {
    override def toString = "HsFront"

    def apply(hashSet: Rep[SHashSet[Int]]): Rep[HsFront] =
      mkHsFront(hashSet)
    def unapply(p: Rep[HsFront]) = unmkHsFront(p)
  }
  def HsFront: Rep[HsFrontCompanionAbs]
  implicit def proxyHsFrontCompanion(p: Rep[HsFrontCompanionAbs]): HsFrontCompanionAbs = {
    proxyOps[HsFrontCompanionAbs](p)
  }

  class HsFrontCompanionElem extends CompanionElem[HsFrontCompanionAbs] {
    lazy val tag = weakTypeTag[HsFrontCompanionAbs]
    protected def getDefaultRep = HsFront
  }
  implicit lazy val HsFrontCompanionElem: HsFrontCompanionElem = new HsFrontCompanionElem

  implicit def proxyHsFront(p: Rep[HsFront]): HsFront =
    proxyOps[HsFront](p)

  implicit class ExtendedHsFront(p: Rep[HsFront]) {
    def toData: Rep[HsFrontData] = isoHsFront.from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoHsFront: Iso[HsFrontData, HsFront] =
    new HsFrontIso

  // 6) smart constructor and deconstructor
  def mkHsFront(hashSet: Rep[SHashSet[Int]]): Rep[HsFront]
  def unmkHsFront(p: Rep[HsFront]): Option[(Rep[SHashSet[Int]])]
}

// Seq -----------------------------------
trait FrontsSeq extends FrontsDsl with ScalanCommunityDslSeq {
  self: FrontsDslSeq =>
  lazy val Front: Rep[FrontCompanionAbs] = new FrontCompanionAbs with UserTypeSeq[FrontCompanionAbs, FrontCompanionAbs] {
    lazy val selfType = element[FrontCompanionAbs]
  }

  case class SeqBaseFront
      (override val set: Rep[Collection[Int]], override val bits: Rep[PBitSet])

    extends BaseFront(set, bits)
        with UserTypeSeq[Front, BaseFront] {
    lazy val selfType = element[BaseFront].asInstanceOf[Elem[Front]]
  }
  lazy val BaseFront = new BaseFrontCompanionAbs with UserTypeSeq[BaseFrontCompanionAbs, BaseFrontCompanionAbs] {
    lazy val selfType = element[BaseFrontCompanionAbs]
  }

  def mkBaseFront
      (set: Rep[Collection[Int]], bits: Rep[PBitSet]) =
      new SeqBaseFront(set, bits)
  def unmkBaseFront(p: Rep[BaseFront]) =
    Some((p.set, p.bits))

  case class SeqHsFront
      (override val hashSet: Rep[SHashSet[Int]])

    extends HsFront(hashSet)
        with UserTypeSeq[Front, HsFront] {
    lazy val selfType = element[HsFront].asInstanceOf[Elem[Front]]
  }
  lazy val HsFront = new HsFrontCompanionAbs with UserTypeSeq[HsFrontCompanionAbs, HsFrontCompanionAbs] {
    lazy val selfType = element[HsFrontCompanionAbs]
  }

  def mkHsFront
      (hashSet: Rep[SHashSet[Int]]) =
      new SeqHsFront(hashSet)
  def unmkHsFront(p: Rep[HsFront]) =
    Some((p.hashSet))
}

// Exp -----------------------------------
trait FrontsExp extends FrontsDsl with ScalanCommunityDslExp {
  self: FrontsDslExp =>
  lazy val Front: Rep[FrontCompanionAbs] = new FrontCompanionAbs with UserTypeDef[FrontCompanionAbs, FrontCompanionAbs] {
    lazy val selfType = element[FrontCompanionAbs]
    override def mirror(t: Transformer) = this
  }

  case class ExpBaseFront
      (override val set: Rep[Collection[Int]], override val bits: Rep[PBitSet])

    extends BaseFront(set, bits) with UserTypeDef[Front, BaseFront] {
    lazy val selfType = element[BaseFront].asInstanceOf[Elem[Front]]
    override def mirror(t: Transformer) = ExpBaseFront(t(set), t(bits))
  }

  lazy val BaseFront: Rep[BaseFrontCompanionAbs] = new BaseFrontCompanionAbs with UserTypeDef[BaseFrontCompanionAbs, BaseFrontCompanionAbs] {
    lazy val selfType = element[BaseFrontCompanionAbs]
    override def mirror(t: Transformer) = this
  }

  object BaseFrontMethods {
    object total {
      def unapply(d: Def[_]): Option[Rep[BaseFront]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[BaseFrontElem] && method.getName == "total" =>
          Some(receiver).asInstanceOf[Option[Rep[BaseFront]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[BaseFront]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object contains {
      def unapply(d: Def[_]): Option[(Rep[BaseFront], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(v, _*), _) if receiver.elem.isInstanceOf[BaseFrontElem] && method.getName == "contains" =>
          Some((receiver, v)).asInstanceOf[Option[(Rep[BaseFront], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[BaseFront], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object append {
      def unapply(d: Def[_]): Option[(Rep[BaseFront], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(v, _*), _) if receiver.elem.isInstanceOf[BaseFrontElem] && method.getName == "append" =>
          Some((receiver, v)).asInstanceOf[Option[(Rep[BaseFront], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[BaseFront], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object BaseFrontCompanionMethods {
    object defaultOf {
      def unapply(d: Def[_]): Option[Unit] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[BaseFrontCompanionElem] && method.getName == "defaultOf" =>
          Some(()).asInstanceOf[Option[Unit]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Unit] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkBaseFront
    (set: Rep[Collection[Int]], bits: Rep[PBitSet]) =
    new ExpBaseFront(set, bits)
  def unmkBaseFront(p: Rep[BaseFront]) =
    Some((p.set, p.bits))

  case class ExpHsFront
      (override val hashSet: Rep[SHashSet[Int]])

    extends HsFront(hashSet) with UserTypeDef[Front, HsFront] {
    lazy val selfType = element[HsFront].asInstanceOf[Elem[Front]]
    override def mirror(t: Transformer) = ExpHsFront(t(hashSet))
  }

  lazy val HsFront: Rep[HsFrontCompanionAbs] = new HsFrontCompanionAbs with UserTypeDef[HsFrontCompanionAbs, HsFrontCompanionAbs] {
    lazy val selfType = element[HsFrontCompanionAbs]
    override def mirror(t: Transformer) = this
  }

  object HsFrontMethods {
    object total {
      def unapply(d: Def[_]): Option[Rep[HsFront]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[HsFrontElem] && method.getName == "total" =>
          Some(receiver).asInstanceOf[Option[Rep[HsFront]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[HsFront]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object contains {
      def unapply(d: Def[_]): Option[(Rep[HsFront], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(v, _*), _) if receiver.elem.isInstanceOf[HsFrontElem] && method.getName == "contains" =>
          Some((receiver, v)).asInstanceOf[Option[(Rep[HsFront], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[HsFront], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object append {
      def unapply(d: Def[_]): Option[(Rep[HsFront], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(v, _*), _) if receiver.elem.isInstanceOf[HsFrontElem] && method.getName == "append" =>
          Some((receiver, v)).asInstanceOf[Option[(Rep[HsFront], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[HsFront], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object set {
      def unapply(d: Def[_]): Option[Rep[HsFront]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[HsFrontElem] && method.getName == "set" =>
          Some(receiver).asInstanceOf[Option[Rep[HsFront]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[HsFront]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object HsFrontCompanionMethods {
    object defaultOf {
      def unapply(d: Def[_]): Option[Unit] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[HsFrontCompanionElem] && method.getName == "defaultOf" =>
          Some(()).asInstanceOf[Option[Unit]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Unit] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkHsFront
    (hashSet: Rep[SHashSet[Int]]) =
    new ExpHsFront(hashSet)
  def unmkHsFront(p: Rep[HsFront]) =
    Some((p.hashSet))

  object FrontMethods {
    object total {
      def unapply(d: Def[_]): Option[Rep[Front]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[FrontElem[_, _]] && method.getName == "total" =>
          Some(receiver).asInstanceOf[Option[Rep[Front]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Front]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object contains {
      def unapply(d: Def[_]): Option[(Rep[Front], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(v, _*), _) if receiver.elem.isInstanceOf[FrontElem[_, _]] && method.getName == "contains" =>
          Some((receiver, v)).asInstanceOf[Option[(Rep[Front], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Front], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object append {
      def unapply(d: Def[_]): Option[(Rep[Front], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(v, _*), _) if receiver.elem.isInstanceOf[FrontElem[_, _]] && method.getName == "append" =>
          Some((receiver, v)).asInstanceOf[Option[(Rep[Front], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Front], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object set {
      def unapply(d: Def[_]): Option[Rep[Front]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[FrontElem[_, _]] && method.getName == "set" =>
          Some(receiver).asInstanceOf[Option[Rep[Front]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Front]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object FrontCompanionMethods {
    object defaultOf {
      def unapply(d: Def[_]): Option[Unit] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[FrontCompanionElem] && method.getName == "defaultOf" =>
          Some(()).asInstanceOf[Option[Unit]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Unit] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object fromCollection {
      def unapply(d: Def[_]): Option[(Rep[Collection[Int]], Rep[Int])] = d match {
        case MethodCall(receiver, method, Seq(col, len, _*), _) if receiver.elem.isInstanceOf[FrontCompanionElem] && method.getName == "fromCollection" =>
          Some((col, len)).asInstanceOf[Option[(Rep[Collection[Int]], Rep[Int])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Collection[Int]], Rep[Int])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object fromHashSet {
      def unapply(d: Def[_]): Option[Rep[SHashSet[Int]]] = d match {
        case MethodCall(receiver, method, Seq(hs, _*), _) if receiver.elem.isInstanceOf[FrontCompanionElem] && method.getName == "fromHashSet" =>
          Some(hs).asInstanceOf[Option[Rep[SHashSet[Int]]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[SHashSet[Int]]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }
}
