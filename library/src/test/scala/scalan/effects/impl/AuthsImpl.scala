package scalan.examples

import scala.reflect.runtime.universe._
import scalan._
import scalan.monads._
import scala.reflect.runtime.universe.{WeakTypeTag, weakTypeTag}
import scalan.meta.ScalanAst._

package impl {
// Abs -----------------------------------
trait AuthenticationsAbs extends Authentications with scalan.Scalan {
  self: AuthenticationsDsl =>

  // single proxy for each type family
  implicit def proxyAuth[A](p: Rep[Auth[A]]): Auth[A] = {
    proxyOps[Auth[A]](p)(scala.reflect.classTag[Auth[A]])
  }

  // familyElem
  class AuthElem[A, To <: Auth[A]](implicit val eA: Elem[A])
    extends EntityElem[To] {
    lazy val parent: Option[Elem[_]] = None
    lazy val entityDef: STraitOrClassDef = {
      val module = getModules("Authentications")
      module.entities.find(_.name == "Auth").get
    }
    lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("A" -> Left(eA))
    }
    override def isEntityType = true
    override lazy val tag = {
      implicit val tagA = eA.tag
      weakTypeTag[Auth[A]].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Reifiable[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[Auth[A]] => convertAuth(x) }
      tryConvert(element[Auth[A]], this, x, conv)
    }

    def convertAuth(x : Rep[Auth[A]]): Rep[To] = {
      assert(x.selfType1 match { case _: AuthElem[_, _] => true; case _ => false })
      x.asRep[To]
    }
    override def getDefaultRep: Rep[To] = ???
  }

  implicit def authElement[A](implicit eA: Elem[A]): Elem[Auth[A]] =
    new AuthElem[A, Auth[A]]

  implicit case object AuthCompanionElem extends CompanionElem[AuthCompanionAbs] {
    lazy val tag = weakTypeTag[AuthCompanionAbs]
    protected def getDefaultRep = Auth
  }

  abstract class AuthCompanionAbs extends CompanionBase[AuthCompanionAbs] with AuthCompanion {
    override def toString = "Auth"
  }
  def Auth: Rep[AuthCompanionAbs]
  implicit def proxyAuthCompanion(p: Rep[AuthCompanion]): AuthCompanion =
    proxyOps[AuthCompanion](p)

  // elem for concrete class
  class LoginElem(val iso: Iso[LoginData, Login])
    extends AuthElem[$bar[Unit,String], Login]
    with ConcreteElem[LoginData, Login] {
    override lazy val parent: Option[Elem[_]] = Some(authElement(sumElement(UnitElement,StringElement)))
    override lazy val entityDef = {
      val module = getModules("Authentications")
      module.concreteSClasses.find(_.name == "Login").get
    }
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map()
    }

    override def convertAuth(x: Rep[Auth[$bar[Unit,String]]]) = // Converter is not generated by meta
!!!("Cannot convert from Auth to Login: missing fields List(user, password)")
    override def getDefaultRep = super[ConcreteElem].getDefaultRep
    override lazy val tag = {
      weakTypeTag[Login]
    }
  }

  // state representation type
  type LoginData = (String, String)

  // 3) Iso for concrete class
  class LoginIso
    extends Iso[LoginData, Login]()(pairElement(implicitly[Elem[String]], implicitly[Elem[String]])) {
    override def from(p: Rep[Login]) =
      (p.user, p.password)
    override def to(p: Rep[(String, String)]) = {
      val Pair(user, password) = p
      Login(user, password)
    }
    lazy val defaultRepTo: Rep[Login] = Login("", "")
    lazy val eTo = new LoginElem(this)
  }
  // 4) constructor and deconstructor
  abstract class LoginCompanionAbs extends CompanionBase[LoginCompanionAbs] with LoginCompanion {
    override def toString = "Login"
    def apply(p: Rep[LoginData]): Rep[Login] =
      isoLogin.to(p)
    def apply(user: Rep[String], password: Rep[String]): Rep[Login] =
      mkLogin(user, password)
  }
  object LoginMatcher {
    def unapply(p: Rep[Auth[$bar[Unit,String]]]) = unmkLogin(p)
  }
  def Login: Rep[LoginCompanionAbs]
  implicit def proxyLoginCompanion(p: Rep[LoginCompanionAbs]): LoginCompanionAbs = {
    proxyOps[LoginCompanionAbs](p)
  }

  implicit case object LoginCompanionElem extends CompanionElem[LoginCompanionAbs] {
    lazy val tag = weakTypeTag[LoginCompanionAbs]
    protected def getDefaultRep = Login
  }

  implicit def proxyLogin(p: Rep[Login]): Login =
    proxyOps[Login](p)

  implicit class ExtendedLogin(p: Rep[Login]) {
    def toData: Rep[LoginData] = isoLogin.from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoLogin: Iso[LoginData, Login] =
    new LoginIso

  // 6) smart constructor and deconstructor
  def mkLogin(user: Rep[String], password: Rep[String]): Rep[Login]
  def unmkLogin(p: Rep[Auth[$bar[Unit,String]]]): Option[(Rep[String], Rep[String])]

  // elem for concrete class
  class HasPermissionElem(val iso: Iso[HasPermissionData, HasPermission])
    extends AuthElem[Boolean, HasPermission]
    with ConcreteElem[HasPermissionData, HasPermission] {
    override lazy val parent: Option[Elem[_]] = Some(authElement(BooleanElement))
    override lazy val entityDef = {
      val module = getModules("Authentications")
      module.concreteSClasses.find(_.name == "HasPermission").get
    }
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map()
    }

    override def convertAuth(x: Rep[Auth[Boolean]]) = // Converter is not generated by meta
!!!("Cannot convert from Auth to HasPermission: missing fields List(user, password)")
    override def getDefaultRep = super[ConcreteElem].getDefaultRep
    override lazy val tag = {
      weakTypeTag[HasPermission]
    }
  }

  // state representation type
  type HasPermissionData = (String, String)

  // 3) Iso for concrete class
  class HasPermissionIso
    extends Iso[HasPermissionData, HasPermission]()(pairElement(implicitly[Elem[String]], implicitly[Elem[String]])) {
    override def from(p: Rep[HasPermission]) =
      (p.user, p.password)
    override def to(p: Rep[(String, String)]) = {
      val Pair(user, password) = p
      HasPermission(user, password)
    }
    lazy val defaultRepTo: Rep[HasPermission] = HasPermission("", "")
    lazy val eTo = new HasPermissionElem(this)
  }
  // 4) constructor and deconstructor
  abstract class HasPermissionCompanionAbs extends CompanionBase[HasPermissionCompanionAbs] with HasPermissionCompanion {
    override def toString = "HasPermission"
    def apply(p: Rep[HasPermissionData]): Rep[HasPermission] =
      isoHasPermission.to(p)
    def apply(user: Rep[String], password: Rep[String]): Rep[HasPermission] =
      mkHasPermission(user, password)
  }
  object HasPermissionMatcher {
    def unapply(p: Rep[Auth[Boolean]]) = unmkHasPermission(p)
  }
  def HasPermission: Rep[HasPermissionCompanionAbs]
  implicit def proxyHasPermissionCompanion(p: Rep[HasPermissionCompanionAbs]): HasPermissionCompanionAbs = {
    proxyOps[HasPermissionCompanionAbs](p)
  }

  implicit case object HasPermissionCompanionElem extends CompanionElem[HasPermissionCompanionAbs] {
    lazy val tag = weakTypeTag[HasPermissionCompanionAbs]
    protected def getDefaultRep = HasPermission
  }

  implicit def proxyHasPermission(p: Rep[HasPermission]): HasPermission =
    proxyOps[HasPermission](p)

  implicit class ExtendedHasPermission(p: Rep[HasPermission]) {
    def toData: Rep[HasPermissionData] = isoHasPermission.from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoHasPermission: Iso[HasPermissionData, HasPermission] =
    new HasPermissionIso

  // 6) smart constructor and deconstructor
  def mkHasPermission(user: Rep[String], password: Rep[String]): Rep[HasPermission]
  def unmkHasPermission(p: Rep[Auth[Boolean]]): Option[(Rep[String], Rep[String])]

  registerModule(scalan.meta.ScalanCodegen.loadModule(Authentications_Module.dump))
}

// Seq -----------------------------------
trait AuthenticationsSeq extends AuthenticationsDsl with scalan.ScalanSeq {
  self: AuthenticationsDslSeq =>
  lazy val Auth: Rep[AuthCompanionAbs] = new AuthCompanionAbs with UserTypeSeq[AuthCompanionAbs] {
    lazy val selfType = element[AuthCompanionAbs]
  }

  case class SeqLogin
      (override val user: Rep[String], override val password: Rep[String])

    extends Login(user, password)
        with UserTypeSeq[Login] {
    lazy val selfType = element[Login]
  }
  lazy val Login = new LoginCompanionAbs with UserTypeSeq[LoginCompanionAbs] {
    lazy val selfType = element[LoginCompanionAbs]
  }

  def mkLogin
      (user: Rep[String], password: Rep[String]): Rep[Login] =
      new SeqLogin(user, password)
  def unmkLogin(p: Rep[Auth[$bar[Unit,String]]]) = p match {
    case p: Login @unchecked =>
      Some((p.user, p.password))
    case _ => None
  }

  case class SeqHasPermission
      (override val user: Rep[String], override val password: Rep[String])

    extends HasPermission(user, password)
        with UserTypeSeq[HasPermission] {
    lazy val selfType = element[HasPermission]
  }
  lazy val HasPermission = new HasPermissionCompanionAbs with UserTypeSeq[HasPermissionCompanionAbs] {
    lazy val selfType = element[HasPermissionCompanionAbs]
  }

  def mkHasPermission
      (user: Rep[String], password: Rep[String]): Rep[HasPermission] =
      new SeqHasPermission(user, password)
  def unmkHasPermission(p: Rep[Auth[Boolean]]) = p match {
    case p: HasPermission @unchecked =>
      Some((p.user, p.password))
    case _ => None
  }
}

// Exp -----------------------------------
trait AuthenticationsExp extends AuthenticationsDsl with scalan.ScalanExp {
  self: AuthenticationsDslExp =>
  lazy val Auth: Rep[AuthCompanionAbs] = new AuthCompanionAbs with UserTypeDef[AuthCompanionAbs] {
    lazy val selfType = element[AuthCompanionAbs]
    override def mirror(t: Transformer) = this
  }

  case class ExpLogin
      (override val user: Rep[String], override val password: Rep[String])

    extends Login(user, password) with UserTypeDef[Login] {
    lazy val selfType = element[Login]
    override def mirror(t: Transformer) = ExpLogin(t(user), t(password))
  }

  lazy val Login: Rep[LoginCompanionAbs] = new LoginCompanionAbs with UserTypeDef[LoginCompanionAbs] {
    lazy val selfType = element[LoginCompanionAbs]
    override def mirror(t: Transformer) = this
  }

  object LoginMethods {
    object toOper {
      def unapply(d: Def[_]): Option[Rep[Login]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[LoginElem] && method.getName == "toOper" =>
          Some(receiver).asInstanceOf[Option[Rep[Login]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Login]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object LoginCompanionMethods {
  }

  def mkLogin
    (user: Rep[String], password: Rep[String]): Rep[Login] =
    new ExpLogin(user, password)
  def unmkLogin(p: Rep[Auth[$bar[Unit,String]]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: LoginElem @unchecked =>
      Some((p.asRep[Login].user, p.asRep[Login].password))
    case _ =>
      None
  }

  case class ExpHasPermission
      (override val user: Rep[String], override val password: Rep[String])

    extends HasPermission(user, password) with UserTypeDef[HasPermission] {
    lazy val selfType = element[HasPermission]
    override def mirror(t: Transformer) = ExpHasPermission(t(user), t(password))
  }

  lazy val HasPermission: Rep[HasPermissionCompanionAbs] = new HasPermissionCompanionAbs with UserTypeDef[HasPermissionCompanionAbs] {
    lazy val selfType = element[HasPermissionCompanionAbs]
    override def mirror(t: Transformer) = this
  }

  object HasPermissionMethods {
    object eA {
      def unapply(d: Def[_]): Option[Rep[HasPermission]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[HasPermissionElem] && method.getName == "eA" =>
          Some(receiver).asInstanceOf[Option[Rep[HasPermission]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[HasPermission]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object toOper {
      def unapply(d: Def[_]): Option[Rep[HasPermission]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[HasPermissionElem] && method.getName == "toOper" =>
          Some(receiver).asInstanceOf[Option[Rep[HasPermission]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[HasPermission]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object HasPermissionCompanionMethods {
  }

  def mkHasPermission
    (user: Rep[String], password: Rep[String]): Rep[HasPermission] =
    new ExpHasPermission(user, password)
  def unmkHasPermission(p: Rep[Auth[Boolean]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: HasPermissionElem @unchecked =>
      Some((p.asRep[HasPermission].user, p.asRep[HasPermission].password))
    case _ =>
      None
  }

  object AuthMethods {
    object toOper {
      def unapply(d: Def[_]): Option[Rep[Auth[A]] forSome {type A}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[AuthElem[_, _]] && method.getName == "toOper" =>
          Some(receiver).asInstanceOf[Option[Rep[Auth[A]] forSome {type A}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Auth[A]] forSome {type A}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object AuthCompanionMethods {
  }
}

object Authentications_Module {
  val packageName = "scalan.examples"
  val name = "Authentications"
  val dump = "H4sIAAAAAAAAAL1WTWwbRRQeb+I4jtOmRChSkSqCcYAisKNKqIccKid1+ZGbmGxbIVMhjddjZ8rszGZmHNYceuAIN8QVod5744KE1AtCQhw4IUDizKkUVRXQExVvZn/8k26aC+xhNPv2zfv5vvfezu17KK8kekF5mGFe9YnGVdfu60pX3AbXVA8vi+6AkYuk99HKV95lvqkctNRGc3tYXVSsjYrRphEG6d4l+01UxNwjSgupNHquaT3UPMEY8TQVvEZ9f6Bxh5Fakyq90USzHdEd7qObKNdEpzzBPUk0cbcYVoqoWD5PTEQ0fS/a9+FOMPLBayaL2lgWVySmGsIHH6ci/V0SuEMu+NDX6GQc2k5gwgKdAvUDIXXiogDm9kQ3eZ3lGARouXkDH+AauOjXXC0p78PJUoC993GfbIOKUZ+FgBVhvSvDwL7PNNGCIvsA0Jt+wKwkDBBCwMA5G0R1hE81xadq8Km4RFLM6IfYfGxJEQ5R9ORmEAoDMPHKE0wkFkiDdysfX/fefeiWfMccDk0oBZvhHBh6NqMaLBWA43e7n6oHr98676CFNlqgqt5RWmJPj1Meo1XCnAttY04BxLIPbJWz2LJe6qAzVRJFT/gB5mAphnIReGLUo9ooG9lizE4G9AUdkEQ1Fwa5NN/VjHxt3Wxhxlp3T7+69nvjHQc5ky6KYNKFwpeJUY1m6wO9F5s26xKIKh0sU2/PZ3kLSEtSH6r7gLz2zddX79/ZzluHy13SwwOmr2E2IFGtxe5HoRjPzktnwddVTqPSXQFJuazR3OhIMZxeC0eknxLx4t0/ut+uo+tOSl+c7fEqBkzk1S8/lX48e8FB823bX5cY7reBQdVgxN+RW4LrNpoXB0RGXwoHmJndYyuoEAMS8zpOyAwQotFq5iQIiGFrw3ZdLgGgFDXOtuCkcqlV+dv9/rPbpi8kWoy+RKPhET3/z68ne9q2DCA9UEQmFM/ARInQMMszEcBWsJp6MsuaRvMBYPKBkN0jz05StBDF4QqfPFV+QN+79Ym2ZOTCyUm007kBrb9hz1WO4CWZiH+1150/T//8hYOKAH+Hah8HlfVj9vF/2JsoBWy0rAVmVos+5VvjztZGs+uM3WqUt1pTH0u5qaac6lNol3wPMwXlU9gUghHMDzNhvYwdOkTu/1cUZq3Z9VwWWitvYNUi0qdKAVhPQu3EhPZIaSzsudjfJJLFXUJ71PxmjkYYRLn6mMlDOR07sRPG8mPyScavlaTD6Uz2wIWSW9ltPs3uXbjjoPxbUAEwc1QT5TtiwLtJLcNdRJNQbyay3GQtQ+1iif20du2zikZhZeb99iTKoLhkwjd3FC/qNZDE0ZMQQ0sRFeMjUTkjLTfuLGjvmw8/3375hy9/s7+RBdOjMOJ4erMZ/31M8rQ8FQbcWMYSAJRN+9rg/wWl4D6yQQoAAA=="
}
}

