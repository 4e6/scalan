package scalan.util

import scalan._
import scalan.common.Default
import scala.reflect.runtime.universe.{WeakTypeTag, weakTypeTag}
import scalan.meta.ScalanAst._

package impl {
// Abs -----------------------------------
trait ExceptionsAbs extends Exceptions with scalan.Scalan {
  self: ExceptionsDsl =>

  // single proxy for each type family
  implicit def proxySThrowable(p: Rep[SThrowable]): SThrowable = {
    proxyOps[SThrowable](p)(scala.reflect.classTag[SThrowable])
  }

  // TypeWrapper proxy
  //implicit def proxyThrowable(p: Rep[Throwable]): SThrowable =
  //  proxyOps[SThrowable](p.asRep[SThrowable])

  implicit def unwrapValueOfSThrowable(w: Rep[SThrowable]): Rep[Throwable] = w.wrappedValue

  implicit lazy val throwableElement: Elem[Throwable] =
    element[SThrowable].asInstanceOf[WrapperElem[_, _]].baseElem.asInstanceOf[Elem[Throwable]]

  // familyElem
  class SThrowableElem[To <: SThrowable]
    extends WrapperElem[Throwable, To] {
    lazy val parent: Option[Elem[_]] = None
    lazy val entityDef: STraitOrClassDef = {
      val module = getModules("Exceptions")
      module.entities.find(_.name == "SThrowable").get
    }
    lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map()
    }
    override def isEntityType = true
    override lazy val tag = {
      weakTypeTag[SThrowable].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Def[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[SThrowable] => convertSThrowable(x) }
      tryConvert(element[SThrowable], this, x, conv)
    }

    def convertSThrowable(x: Rep[SThrowable]): Rep[To] = {
      x.selfType1 match {
        case _: SThrowableElem[_] => x.asRep[To]
        case e => !!!(s"Expected $x to have SThrowableElem[_], but got $e")
      }
    }
    lazy val baseElem = {
      new BaseTypeElem[Throwable, SThrowable](this.asInstanceOf[Element[SThrowable]])(weakTypeTag[Throwable], DefaultOfThrowable)
    }
    lazy val eTo: Elem[_] = new SThrowableImplElem(isoSThrowableImpl)
    override def getDefaultRep: Rep[To] = ???
  }

  implicit def sThrowableElement: Elem[SThrowable] =
    elemCache.getOrElseUpdate(
      (classOf[SThrowableElem[SThrowable]], Nil),
      new SThrowableElem[SThrowable]).asInstanceOf[Elem[SThrowable]]

  implicit case object SThrowableCompanionElem extends CompanionElem[SThrowableCompanionAbs] {
    lazy val tag = weakTypeTag[SThrowableCompanionAbs]
    protected def getDefaultRep = SThrowable
  }

  abstract class SThrowableCompanionAbs extends CompanionDef[SThrowableCompanionAbs] with SThrowableCompanion {
    def selfType = SThrowableCompanionElem
    override def toString = "SThrowable"
  }
  def SThrowable: Rep[SThrowableCompanionAbs]
  implicit def proxySThrowableCompanion(p: Rep[SThrowableCompanion]): SThrowableCompanion =
    proxyOps[SThrowableCompanion](p)

  // default wrapper implementation
  abstract class SThrowableImpl(val wrappedValue: Rep[Throwable]) extends SThrowable with Def[SThrowableImpl] {
    lazy val selfType = element[SThrowableImpl]

    def getMessage: Rep[String] =
      methodCallEx[String](self,
        this.getClass.getMethod("getMessage"),
        List())

    def initCause(cause: Rep[SThrowable]): Rep[SThrowable] =
      methodCallEx[SThrowable](self,
        this.getClass.getMethod("initCause", classOf[AnyRef]),
        List(cause.asInstanceOf[AnyRef]))
  }
  trait SThrowableImplCompanion
  // elem for concrete class
  class SThrowableImplElem(val iso: Iso[SThrowableImplData, SThrowableImpl])
    extends SThrowableElem[SThrowableImpl]
    with ConcreteElem[SThrowableImplData, SThrowableImpl] {
    override lazy val parent: Option[Elem[_]] = Some(sThrowableElement)
    override lazy val entityDef = {
      val module = getModules("Exceptions")
      module.concreteSClasses.find(_.name == "SThrowableImpl").get
    }
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map()
    }
    override lazy val eTo: Elem[_] = this
    override def convertSThrowable(x: Rep[SThrowable]) = // Converter is not generated by meta
!!!("Cannot convert from SThrowable to SThrowableImpl: missing fields List(wrappedValue)")
    override def getDefaultRep = SThrowableImpl(DefaultOfThrowable.value)
    override lazy val tag = {
      weakTypeTag[SThrowableImpl]
    }
  }

  // state representation type
  type SThrowableImplData = Throwable

  // 3) Iso for concrete class
  class SThrowableImplIso
    extends Iso[SThrowableImplData, SThrowableImpl] {
    override def from(p: Rep[SThrowableImpl]) =
      p.wrappedValue
    override def to(p: Rep[Throwable]) = {
      val wrappedValue = p
      SThrowableImpl(wrappedValue)
    }
    lazy val eTo = new SThrowableImplElem(this)
  }
  // 4) constructor and deconstructor
  class SThrowableImplCompanionAbs extends CompanionDef[SThrowableImplCompanionAbs] {
    def selfType = SThrowableImplCompanionElem
    override def toString = "SThrowableImpl"

    def apply(wrappedValue: Rep[Throwable]): Rep[SThrowableImpl] =
      mkSThrowableImpl(wrappedValue)
  }
  object SThrowableImplMatcher {
    def unapply(p: Rep[SThrowable]) = unmkSThrowableImpl(p)
  }
  lazy val SThrowableImpl: Rep[SThrowableImplCompanionAbs] = new SThrowableImplCompanionAbs
  implicit def proxySThrowableImplCompanion(p: Rep[SThrowableImplCompanionAbs]): SThrowableImplCompanionAbs = {
    proxyOps[SThrowableImplCompanionAbs](p)
  }

  implicit case object SThrowableImplCompanionElem extends CompanionElem[SThrowableImplCompanionAbs] {
    lazy val tag = weakTypeTag[SThrowableImplCompanionAbs]
    protected def getDefaultRep = SThrowableImpl
  }

  implicit def proxySThrowableImpl(p: Rep[SThrowableImpl]): SThrowableImpl =
    proxyOps[SThrowableImpl](p)

  implicit class ExtendedSThrowableImpl(p: Rep[SThrowableImpl]) {
    def toData: Rep[SThrowableImplData] = isoSThrowableImpl.from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoSThrowableImpl: Iso[SThrowableImplData, SThrowableImpl] =
    cachedIso[SThrowableImplIso]()

  // 6) smart constructor and deconstructor
  def mkSThrowableImpl(wrappedValue: Rep[Throwable]): Rep[SThrowableImpl]
  def unmkSThrowableImpl(p: Rep[SThrowable]): Option[(Rep[Throwable])]

  registerModule(scalan.meta.ScalanCodegen.loadModule(Exceptions_Module.dump))
}

// Seq -----------------------------------
trait ExceptionsSeq extends ExceptionsDsl with scalan.ScalanSeq {
  self: ExceptionsDslSeq =>
  lazy val SThrowable: Rep[SThrowableCompanionAbs] = new SThrowableCompanionAbs {
    override def apply(msg: Rep[String]): Rep[SThrowable] =
      SThrowableImpl(new Throwable(msg))
  }

  // override proxy if we deal with TypeWrapper
  //override def proxyThrowable(p: Rep[Throwable]): SThrowable =
  //  proxyOpsEx[Throwable, SThrowable, SeqSThrowableImpl](p, bt => SeqSThrowableImpl(bt))

  case class SeqSThrowableImpl
      (override val wrappedValue: Rep[Throwable])
    extends SThrowableImpl(wrappedValue) with SeqSThrowable {
    override def getMessage: Rep[String] =
      wrappedValue.getMessage

    override def initCause(cause: Rep[SThrowable]): Rep[SThrowable] =
      SThrowableImpl(wrappedValue.initCause(cause))
  }

  def mkSThrowableImpl
    (wrappedValue: Rep[Throwable]): Rep[SThrowableImpl] =
    new SeqSThrowableImpl(wrappedValue)
  def unmkSThrowableImpl(p: Rep[SThrowable]) = p match {
    case p: SThrowableImpl @unchecked =>
      Some((p.wrappedValue))
    case _ => None
  }

  implicit def wrapThrowableToSThrowable(v: Throwable): SThrowable = SThrowableImpl(v)
}

// Exp -----------------------------------
trait ExceptionsExp extends ExceptionsDsl with scalan.ScalanExp {
  self: ExceptionsDslExp =>
  lazy val SThrowable: Rep[SThrowableCompanionAbs] = new SThrowableCompanionAbs {
    def apply(msg: Rep[String]): Rep[SThrowable] =
      newObjEx(classOf[SThrowable], List(msg.asRep[Any]))
  }

  case class ExpSThrowableImpl
      (override val wrappedValue: Rep[Throwable])
    extends SThrowableImpl(wrappedValue)

  object SThrowableImplMethods {
  }

  def mkSThrowableImpl
    (wrappedValue: Rep[Throwable]): Rep[SThrowableImpl] =
    new ExpSThrowableImpl(wrappedValue)
  def unmkSThrowableImpl(p: Rep[SThrowable]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: SThrowableImplElem @unchecked =>
      Some((p.asRep[SThrowableImpl].wrappedValue))
    case _ =>
      None
  }

  object SThrowableMethods {
    object getMessage {
      def unapply(d: Def[_]): Option[Rep[SThrowable]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[SThrowableElem[_]] && method.getName == "getMessage" =>
          Some(receiver).asInstanceOf[Option[Rep[SThrowable]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[SThrowable]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object initCause {
      def unapply(d: Def[_]): Option[(Rep[SThrowable], Rep[SThrowable])] = d match {
        case MethodCall(receiver, method, Seq(cause, _*), _) if receiver.elem.isInstanceOf[SThrowableElem[_]] && method.getName == "initCause" =>
          Some((receiver, cause)).asInstanceOf[Option[(Rep[SThrowable], Rep[SThrowable])]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[SThrowable], Rep[SThrowable])] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object SThrowableCompanionMethods {
    object apply {
      def unapply(d: Def[_]): Option[Rep[String]] = d match {
        case MethodCall(receiver, method, Seq(msg, _*), _) if receiver.elem == SThrowableCompanionElem && method.getName == "apply" =>
          Some(msg).asInstanceOf[Option[Rep[String]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[String]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }
}

object Exceptions_Module {
  val packageName = "scalan.util"
  val name = "Exceptions"
  val dump = "H4sIAAAAAAAAALVVv28cRRR+t3Z8vh/ESZAiOU2MdSEQhTsrTQoXkTlfENL5h7JWQJcIaW5vfJ4wOzPemXP2KFKkhA7RIkjvjoZ/AAlRUCFAoqYKUERAKlDezO7e7VlskoYtRjszb9/73vd9M3v8O5zSEbyuA8KJaIbUkKbv3je0afgdYZgZb8nBiNNNuv/w/NfBlnhbe7DUg4UDojc170EleenEavLu08MuVIgIqDYy0gZe67oKrUByTgPDpGixMBwZ0ue01WXarHdhvi8H40N4AKUunAmkCCJqqN/mRGuq0/VFahGxybzi5uMdNa0hWraLVq6LvYgwg/Cxxpkk/hZV/lhIMQ4NnE6h7SgLC2PKLFQyMlmJMqY7kINsOi8ILsC57j1yRFpYYtjyTcTEEL+sKRJ8SIZ0G0Ns+DwC1pTv742Vm891oarpIRL0bqi4W4kVAKAC1xyI5pSf5oSfpuWn4dOIEc4+InZzN5LxGJKnNAcQK0xx9QUpsgy0IwaNj+8Gd576tdCzH8cWStl1uICJLha4wUmBPH5761P95J1H1z2o9qDK9EZfm4gEJi95ylaNCCGNwzwhkERDVGu1SC1XZQNjTliiEshQEYGZUirrqBNnATM22K7VU3UKqC8bRbPQUqxKk35XCvp1vmkTzncfL7916bfO+x54syUqmNJH40dZUgNVf+8gkvct645VO1RSgotLTZq+/PiPwTdrcNebUJVmfjl1MMUp/fOPtR/evOHBYs95+SYnwx6ypTuchjtRWwrTg0V5RKNkp3xEuH37T7XKA7pPRtykHOabn8PmDawUnjpFLTPrzuGljIBaYtJtKWjj5m7jb/+7z46tByOoJzvJMfyXXf/nl9P7xtnTQP1+RJSig9uEj5Kzv2RgDk9xykq6UimiPhXADhdc8Dk3x8M/VSs7khdy376Q9Oxq+au35v25/NMXHlSQ2z4zIVGNtZc8EP+jyWGWoJqNfM9xmSBasMPFbLvYuzkCrYrVRCtfhvTs6hP2waNPjDNsKZ69GXf69/AqWncfL7sqjROI6p24nbW8lt+yw8pzUDip0BqvTjG389wlMio7nj0pqx0vzS6iF6qdOKDOfXg91VLBR4ZxB+gqtr1a4AI/1QCN8ODp59tXvv/qV3dVVK2a6HRhZv4eTrr4hHdfmVbH/0MOrIF5q/EExBuFIA6thWmI5Zy/HsLt481rX4ZOmSUaJz7ayv3NYkdP+Rm79/3MBQgAAA=="
}
}

trait ExceptionsDsl extends impl.ExceptionsAbs {self: ExceptionsDsl =>}
trait ExceptionsDslExp extends impl.ExceptionsExp {self: ExceptionsDslExp =>}
