/**
 * Author: Alexander Slesarenko
 * Date: 1/26/13
 */
package scalan.collections

import scalan._
import scalan.sequential.ScalanSeq
import staged.{ ExpressionsBase, ScalanStaged }
import scalan.common.{ Common, Zero }
import scalan.staged.ScalanStagedImplementation
import scalan.sequential.ScalanSeqImplementation

//==============================================================================
// DSL level
trait SetsOps { self: SetsDsl =>
  implicit def psetElement[A: Elem]: Elem[PSet[A]] = element[PSetImpl[A]].asInstanceOf[Elem[PSet[A]]]

  trait PSetOps[A] extends PSet[A] {
    def apply(elem: Rep[A]): Rep[Boolean] = this.contains(elem)
  }
  
  trait PSetImplOps[A] extends PSetOps[A] {
    def union(that: PS[A]) = setFromMap(toMap.union(that.toMap))
    def difference(that: PS[A]) = setFromMap(toMap.difference(that.toMap))
    def isEmpty = toMap.isEmpty
    def contains(elem: Rep[A]) = toMap.contains(elem)
    def toArray = toMap.toArray.map(_._1)
    def size = toMap.size    
  }

  trait PSetCompanion {
  }
  
  trait PSetImplCompanion extends PSetCompanion {
    def empty[A: Elem] = setFromMap(PMap.empty[A, Unit])
    def fromArray[A: Elem](arr: PArray[A]) = setFromArray(arr)
    def singleton[A: Elem](x: Rep[A]) = fromArray(self.singleton(x))    
  }
  
  def setFromMap[A: Elem](map: PM[A, Unit]): Rep[PSet[A]] = PSetImpl(map)
  def emptySet[A: Elem] = setFromMap(PMap.empty[A, Unit])
  def setFromArray[A: Elem](arr: PArray[A]) = setFromMap(PMap.fromArray(arr.map(x => (x, toRep(())))))
  def singletonSet[A: Elem](x: Rep[A]) = setFromArray(singleton(x))
}

trait SetsDsl extends SetsAbs with SetsOps with Scalan

trait SetsDslSeq extends SetsDsl with SetsSeq with SeqMaps { self: ScalanSeq => }

trait SetsDslExp extends SetsDsl with SetsExp with StagedMaps { self: ScalanStaged => }