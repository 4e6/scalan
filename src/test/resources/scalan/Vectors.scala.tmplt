package scalan.math

import scalan.Scalan
import scalan.ScalanDsl
import scalan.sequential.ScalanSeq
import scalan.lms.common.ProxyExp
import scalan.staged._

trait Vectors extends Scalan { self: VectorsDsl =>

  type Vec[A] = Rep[Vector[A]]
  trait Vector[A] {
    implicit def eA: Elem[A]
    def items: PA[A]
    def nonZeroItems: PA[(Int, A)]
    def length: Rep[Int]
    def +^(other: Vec[A])(implicit num: Numeric[A]): Vec[A]
    def -^(other: Vec[A])(implicit num: Numeric[A]): Vec[A]
    def *^(other: Vec[A])(implicit num: Numeric[A]): Vec[A]
    def apply(i: Rep[Int]): Rep[A]
    def reduce(implicit m: RepMonoid[A]): Rep[A]
    def map[B: Elem](f: Rep[A] => Rep[B]): Vec[B]
    def indexes: PA[Int] = indexRange(length)
    def <<-(is: PA[Int], vs: PA[A]): Vec[A]
    def +^(y: Rep[A])(implicit num: Numeric[A], o: Overloaded1): Vec[A] = map(x => x + y)
    def -^(y: Rep[A])(implicit num: Numeric[A], o: Overloaded1): Vec[A] = map(x => x - y)
    def *^(y: Rep[A])(implicit num: Numeric[A], o: Overloaded1): Vec[A] = map(x => x * y)
    def +^(ys: PA[A])(implicit num: Numeric[A], o: Overloaded2): Vec[A] = +^(DenseVector(ys))
    def -^(ys: PA[A])(implicit num: Numeric[A], o: Overloaded2): Vec[A] = -^(DenseVector(ys))
    def *^(ys: PA[A])(implicit num: Numeric[A], o: Overloaded2): Vec[A] = *^(DenseVector(ys))
    def zeroA = eA.defaultOf
  }

  abstract class DenseVector[A](val items: Rep[PArray[A]])(implicit val eA: Elem[A])
    extends Vector[A] {
    def ->>(is: PA[Int]): Rep[PArray[A]] = items ->> is
    def length = items.length
    def nonZeroItems = indexes.zip(items).filter(_._2 !== zeroA)
    def +^(other: Vec[A])(implicit num: Numeric[A]): Vec[A] = DenseVector(items +^ other.items)
    def -^(other: Vec[A])(implicit num: Numeric[A]): Vec[A] = DenseVector(items -^ other.items)
    def *^(other: Vec[A])(implicit num: Numeric[A]): Vec[A] = DenseVector(items *^ other.items)
    def apply(i: Rep[Int]): Rep[A] = items(i)
    def reduce(implicit m: RepMonoid[A]): Rep[A] = items.reduce
    def <<-(is: PA[Int], vs: PA[A]): Rep[DenseVector[A]] = DenseVector(items <<- (is, vs))
    def <<-(i: Rep[Int], v: Rep[A])(implicit o: Overloaded1): Rep[DenseVector[A]] = <<-(singleton(i), singleton(v))
    def map[B: Elem](f: Rep[A] => Rep[B]): Vec[B] = DenseVector(items.map(f))
  }

  trait DenseVectorCompanion {
    implicit def paToVec[A](xs: PA[A]) = DenseVector(xs)(xs.elem)
    implicit def vecToPa[A](xs: DenseVector[A]) = xs.items
  }

  abstract class SparseVector[A](val nonZeroItems: Rep[PArray[(Int, A)]], val length: Rep[Int])(implicit val eA: Elem[A])
    extends Vector[A] {
    private def nonZeroIndices = nonZeroItems.as
    private def nonZeroValues = nonZeroItems.bs
    def items = replicate(length, zeroA) <<- (nonZeroIndices, nonZeroValues)
    def +^(other: Vec[A])(implicit num: Numeric[A]): Vec[A] =
      SparseVector((nonZeroItems, other.nonZeroItems).outerJoin { (x: Rep[A], y: Rep[A]) => x + y } { (x: Rep[A]) => x } { (x: Rep[A]) => x },
        length)
    def *^(other: Vec[A])(implicit num: Numeric[A]): Vec[A] =
      SparseVector((nonZeroItems, other.nonZeroItems).innerJoin { (x: Rep[A], y: Rep[A]) => x * y }, length)
    def -^(other: Vec[A])(implicit num: Numeric[A]): Vec[A] =
      SparseVector((nonZeroItems, other.nonZeroItems).outerJoin { (x: Rep[A], y: Rep[A]) => x - y } { (x: Rep[A]) => x } { (x: Rep[A]) => -x },
        length)
    def apply(i: Rep[Int]): Rep[A] = ???
    def reduce(implicit m: RepMonoid[A]): Rep[A] = nonZeroValues.reduce
    def <<-(is: PA[Int], vs: PA[A]): Rep[DenseVector[A]] = ???
    def map[B](f: Rep[A] => Rep[B])(implicit eB: Elem[B]): Vec[B] = {
      val fZero = f(zeroA)
      IF(fZero === eB.defaultOf) THEN {
        SparseVector(nonZeroItems.map {
          case Pair(i, x) => (i, f(x))
        }, length).asRep[Vector[B]]
      } ELSE {
        val arr = replicate(length, fZero)
        DenseVector(arr <<- (nonZeroIndices, nonZeroValues.map(f)))
      }
    }
  }

  trait SparseVectorCompanion

  def dot[A: Numeric: Elem: RepMonoid](xs: Vec[A], ys: Vec[A]) = (xs *^ ys).reduce
}

trait VectorsDsl extends impl.VectorsAbs with Vectors {
  implicit def sparseVectorDataElem[A](implicit eA: Elem[A]) =
    pairElement(parrayElement(pairElement(intElement, eA)), intElement)
}

trait VectorsDslSeq extends VectorsDsl with impl.VectorsSeq with ScalanSeq

trait VectorsDslExp extends VectorsDsl with impl.VectorsExp with ScalanStaged